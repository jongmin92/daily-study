# 32비트와 64비트
- 구분의 두 가지 기준
    - 한번에 송수신 가능한 데이터 크기 (= I/O Bus)
    - 데이터 처리 능력 (= CPU가 한번에 읽어들일 수 있는 명령어 크기)
> 32비트 시스템에서는 포인터의 크기가 32비트이고, 64비트 시스템에는 포인터의 크기가 64비트이다. (**`포인터`는 `메모리의 주소`를 가리킨다.**)

## 프로그래머 입장에서의 64비트 컴퓨터
- 32비트 -> 64비트
    - 프로그램으로 표현할 수 있는 범위의 증가
    - 표현할 수 있는 메모리의 전체 크기
> **`32비트 시스템`(OS)에서는 `최대 4GB`의 메모리까지 인식이 가능하다.** 그 이유에 대해서 알아보자.
32비트 시스템에서는 메모리의 주소를 가리키는 포인터가 32비트라고 했다. 32비트를 이용해 표현 가능한 경우의 수는 2의 32승이고, 이는 2의2승 X 2의30승과 같다. 2의2승은 4이고, 2의30승은 컴퓨터 세계에서 사용하는 G(기가)로 표현된다.  
>
>즉, 32비트로 표현 가능한 경우의 수 = 2의 32승 = 2의 2승 X 2의 30승 = 4G 이다. 그리고 메모리의 저장 단위는 바이트(Byte)이기 때문에, 32비트에서 사용가능한 총 메모리의 용량은 총 4GB가 되는 것이다.
>> 메모리 저장 단위와 메모리 크기 표시 단위
>> - 메모리에 데이터를 저장할 때 사용하는 최소 단위는 비트(bit)이지만 비트 단위로 데이터를 연산하거나 데이터를 관리하는 것보다 바이트(byte) 단위로 관리하는 것이 효율적이므로 **연산 장치와 메모리는 기본 단위로 바이트를 사용한다.**
>> - 운영체제는 많은 양의 메모리를 관리하기 위해 바이트 크기마다 숫자를 매겨서 관리한다. 이 숫자가 주소이다. **운영체제 입장에서는 이 주소도 정보이기 때문에 어떤 크기로 저장할 것인가를 결정해야 하는데 주소 데이터의 코기는 보통 운영체제의 기본 처리 단위와 일치한다.**  
>>
>> 참고) https://m.blog.naver.com/PostView.nhn?blogId=tipsware&logNo=221537443580&proxyReferer=https%3A%2F%2Fwww.google.com%2F

## 64비트 기반 프로그래밍
- 64비트 기반 프로그래밍
    - 64비트 시스템을 고려한 프로그래밍으로 자료형에 대해서 고려해야 한다.
    - 데이터 손실의 문제 (64비트 시스템에서 포인터(배열 이름)는 8바이트, int는 4바이트)
    - 포인터를 절대 기본자료형으로 캐스팅하지 말자.
        ```c
        #include <stdio.h>
        int main(void) {
            int arr[10] = {0, };
            int arrVal = (int)arr;  // 데이터 손실이 발생할 수 있는 위치
            printf("pointer: %d\n", arrVal);
            return 0;
        }
        ```
