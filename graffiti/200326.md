# JVM 생존 주기
main() 메서드를 가진 자바 클래스가 JVM을 통해서 어떻게 동작하는지 자세히 알아본다.

## 초기 진입 단계
CPU는 부팅되면 기억 장치 주소 0번부터 처리하므로 주소 0번이 진입점일 것이다. C언어와 자바는 main() 함수부터 시작하니 이곳이 진입점이다.
**JVM 클래스 로더 중에서 `부트스트랩 클래스 로더`라는 것이 있는데 이 클래스 로더가 class 파일들을 읽고, 클래스 파일 검증과 로딩과 같은 처리를 한 후에 Static Scope에 존재하는 메서드인 public static main() 메서드를 통해서 프로그램을 시작한다.**

main이라는 함수명이 약속되어 있기 때문에 JVM은 특정 클래스를 객체로 만들지 않고 메서드를 호출 할 수 있게 된다. 그리고 main() 메서드가 종료되면 JVM 생존 주기는 종료 된다.

## 클래스 로딩 단계
클래스는 클래스 로더에 의해서 읽어지며, JVM 니모닉 중 <clinit>으로 클래스 로드가 표현된다.

### 클래스 로드 순서
- 클래스 로더를 생성할 때 부모 클래스 로더를 매개변수로 넘긴다. 이때 명시되지 않으면 부모 클래스 로더는 시스템 클래스 로더가 된다.
- 이미 클래스가 로드되었으면, 바로 그 클래스를 반환한다. 아니면 부모 클래스에서 새 클래스를 찾게 된다. 시스템 클래스 로더에 도달할 떄까지 검색이 반복된다. 시스템 클래스 로더에서도 찾지 못하면 예외가 발생한다.
    - findClass() 메서드는 현재 클래스 로더에서 클래스를 검색할 때 사용한다. 클래스 로더를 확장할 때 이 메서드를 재정의 한다.
    
### 클래스 로더 경로 검색 순서
- Bootstrap classes
    - JRE가 설치된 폴더의 lib 폴더에 있는 클래스들을 의미한다. JVM이 구동될 때 반드시 있어야 하는 클래스가 있다.
- Installed extensions
    - JRE가 설치된 폴더의 lib/ext 폴더 안에 있는 클래스들을 의미한다. 보안 클래스 등 확장 API 관련 클래스가 있다.
- Class Path
    - 클래스로더가 마지막으로 검색하는 경로이다. System 프로퍼티 java.class.path에 명시할 수 있다. 컴파일 할 때 -classpath 혹은 CLASSPATH 환경 변수 등으로도 지정할 수 있다.

클래스는 패키지 명을 포함한 정확한 클래스 명을 사용해서 로딩된다. 패키지는 이름 공간 역할을 하기 때문에 동일한 클래스 명이 패키지 명에 따라 충돌하지 않게 해준다. 이미 발견된 클래스에 대한 참조를 또 만나면 이전에 캐시된 클래스가 반환된다.

클래스 로드는 main() 메서드를 수행하는 도중에 다른 클래스에 대한 참조를 만날 때 연쇄적으로 시작된다. (JVM이 시작될 때 모든 클래스를 바로 로드하면 너무 오래 걸리기 때문이다. 지연된 로드를 통해 부하를 분산하는 것이다.)

클래스를 로드할 때, 클래스 로더는 defineClass() 메서드를 사용해서 클래스를 정의한다. 이렇게 정의된 클래스는 객체를 생성할 수 있는 상태가 된다.

> example code: https://github.com/jongmin92/code-examples/tree/master/java/class-loader

### 클래스 연결 단계
main() 메서드 안의 코드가 수행되는 과정에서 클래스에 대한 연결 과정이 일어난다. 코드 중에 native 메서드가 존재하면 linking 대신 바인딩이 일어난다. (JVM Spec에서는 그렇게 명시하지만 일반적으로 둘 다 바인딩으로 표현한다.)

클래스 연결은 크게 검증, 준비, 해석 단계를 가진다.

- 검증
    - 클래스 안에 있는 정보가 올바른지 확인하는 단계이다.
    - 클래스 포맷 자체가 올바른지, 호출 진행시 연산자 스택 개수가 맞지 않은지, 연산자 스택이 overflow 되는지, 생성 시에 부모 생성자를 호출하는지 등을 검증한다.
- 준비
    - 초기화 되지 않은 값에 기본 값을 설정하는 단계이다.
    - C나 C++에서는 초기값을 설정하지 않으면 garbage 값이 들어가지만, 자바는 0이나 null 값으로 초기화 된다.
- 해석
    - 심벌의 참조 값을 Runtime Constant Pool로부터 가져오는 단계이다.
    - 이 단계는 심벌 테이블 검색으로 이해할 수 있다.

### 클래스 객체화 단계
객체 생성에는 생성자, newInstance(), clone(), Serializable, Externalizable interface와 ObjectStream을 사용, 한 객체 생성할 때 모든 부모 클래스가 되는 등의 방법이 있다. 객체 생성과 함께 Static Context도 초기화 된다.

### 객체 가비지 컬렉션 단계
GC가 어떻게 동작하는지 간단하게 알아본다. GC가 수행되는 대상은 null인 객체, 지역 변수, static 객체, 순환 참조를 가지는 객체 등에 수행된다.  
JVM 알고리즘에 따라 언제 객체가 GC가 될 것인지 얼마나 자주 GC를 할 것인지 등이 결정된다. (코드 상에서 특정 객체를 사용하고 난 후에 null로 참조를 할당해 두면, 다음 GC 실행 때, 메모리에서 해제될 가능성이 높다.)
```
con.close();
con = null;
```
>- 지역 변수: Stack 영역 객체로써 메서드 호출 종료 시 자동으로(auto 변수) 제거된다.
>- static 객체: static 객체의 경우 Heap이 아닌 Class 영역에 있다.

GC가 수행될 때, 객체의 finalize() 메서드가 GC에 의해서 호출된다. (GC의 실행 시점은 비 확정적이기 때문에 finalize를 재정의하는 방법은 거의 사용하지 않는다.)

native 메서드를 사용한 경우 OS 메모리나 자원에 대한 권한이 없으므로 이에 대한 해결책으로 다음과 같은 방법을 사용한다.  
1. 자원 생성과 해제 메서들 쌍으로 제공한다. JDBC가 대표적인 예로 try~catch~finally 구문을 통해서 생성과 해제를 명시적으로 한다.
2. JVM이 관여하지 않아도 되는 Stack Scope의 변수만을 사용해서 native 메서드를 구현한다.
