# 객체 지향 언어의 특징
## 상속
- **구현 상속**
    - 부모 클래스가 가진 능력과 속성들을 자식에게 넘겨준다.
    - 자바에서 능력과 속성은 메서드와 변수로 나타난다.
    - 구현 상속을 사용하면 똑같은 코드를 재작성 할 필요 없이 부모 클래스의 기능들을 사용할 수 있게 된다.
- **구조 상속**
    - 부모 클래스로부터의 구조를 자식에게 심어줌으로써 동일한 메시지를 처리할 수 있는 클래스 집단을 만드는 과정이다.
    - 구현 상속을 하더라도 자식에게 구조는 심어진다.
    - 차이점은 구조 상속은 구현을 포함하지 않은 구조만 심어주는 것이 가능하다.
        - interface는 구조만 심어주고(implements), 추상 클래스는 구현도 심어준다(extends).
- **다중 상속**
    - 자바에서는 원칙적으로 extends를 통해서 2개 이상의 클래스를 확장할 수 없다.
    - 자바에서는 다중 상속의 개념이 구현 상속 대신 구조 상속을 통해서 한 클래스가 다양한 interface를 구현하도록 할 수 있다.
    
## 다형성
- 구현 바인딩
    - 구현 바인딩은 구조에 구현을 붙인다는 의미이다. 구현은 메서드의 구현 코드를 의미한다.
    - 구조는 interface, 추상 클래스로 표현되고 Concrete Class 안의 메서드나 JNI 메서드가 연결 된다. 이 연결을 바인딩이라고 부른다.
    - 자바에서 타입은 정적 영역의 Context에 저장된다. 그렇기 때문에 타입에 대해서 동적으로 타입 변경을 할 수 없다.
    - 동적 타입 변경과 동적 바인딩을 흉내 낼 수 있는 방법은 Proxy, Reflection API를 사용하는 것이다. 이 방법은 컴파일러가 수행하는 바인딩(자동 바인딩)이 아닌 수동 바인딩이라고 볼 수 있다. (성능 하락을 발생시킬 수 있지만, 훨씬 더 큰 유연성을 제공한다.)

## Interface
- Abstract Class
    - 구현은 없고 정의만 있는 메서드를 추상 메서드라고 한다.
    - 추상 메서드를 하나라도 포함하는 클래스는 추상 클래스이다.
    - 추상 클래스는 모든 메서드가 구현되기 전까지는 객체화 될 수 없다. Concrete Class에서 추상 메서드를 구현한다.
- Interface
    - 자바에서 interface는 모든 메서드가 public abstract(추상) 메서드인 추상 클래스이다. (자바8에는 default 메서드가 추가되었다.)
    - 다중 interface 구현은 클래스가 여러 역할을 수행할 수 있다는 것을 표현한다.
    - 특정 interface 변수에 바인딩 되면, 그 interface의 메서드들만 외부로 드러내게 된다.

## Generic Class
- 자바 5.0에 추가된 기능이다.
- Generic Class는 컴파일 시간에 타입을 검사하고, 실행 시간에 타입이 제거된다.

## Meta Class
- **Meta Class(Class 클래스)는 특정 클래스를 설명하기 위해 사용하는 클래스이다.**
- 모든 클래스는 이 Meta Class에 해당하는 객체를 Static Scope에 가지고 있다.
- 클래스명.class가 바로 그것이다.
- 자바 Reflection API를 사용해서 메타 클래스에서 정보를 얻을 수 있다.

## 생성자
- new 생성자(); 로 객체를 생성한다.
    - JVM은 \<clinit> 이라는 특수한 명령을 통해 클래스를 로딩한다.
    - 그 다음 Object 객체 형태로 메모리를 할당한 후에 \<init>이라는 또 다른 특별한 명령을 통해 객체를 초기화 한다.
- 내부적으로 배열 타입은 약간 다르게 생성된다. 배열에 대한 생성 명령이 따로 JVM 명령으로 존재한다.

# 자바 가상 머신 (JVM)
- 자바는 코드 컴파일 후 CPU가 직접 컴파일 된 코드를 다루는 것이 아니라 자바 가상 머신이 명령을 해석해서 CPU나 OS가 인식할 수 있는 명령으로 변경해서 전달한다.
 
## 자바 가상머신의 역할
- JVM은 객체들의 생존 주기를 관리하고 응용 프로그램이 올바르게 동작하도록 한다.
- java 명령어로 클래스를 실행시키면 JVM이 구동된 것이라고 생각하면 된다.
- 컴파일 된 클래스의 코드 부분을 바이트 코드라고 부른다. 이 바이트 코드를 JVM이 처리한다.

## 바이트 코드, 니모닉, 피연산자, 연산 코드
- 소스 파일은 텍스트 형태로 저장한다. 하지만 컴파일 되면 바이너리 형태의 class 파일로 저장된다.
- class 파일 안에는 바이트 코드와 클래스에 대한 상수, 연산 정보 등이 들어 있다.
- 바이트 코드는 명령어 집합들로 표현되고, 이 명령어 집합들은 각각의 니모닉과 연산 코드(니모닉에 1:1로 매핑되는 프로세서 연산의 코드)를 갖고 있다.
- JVM은 기본 데이터 형 및 객체를 스택을 기반으로 처리한다. 여기에 사용되는 스택을 연산자 스택(Operand Stack)이라고 한다.
- 어셈블리어는 니모닉과 피연산자로 연산을 표시하고 니모닉과 피연산자는 연산 코드와 피연산자(값이나 참조)로 변환되어 실행 코드에 저장한다. 그리고 연산 코드는 프로세서에 의해 수행된다.

## JVM Context (JVM 데이터 영역)
Class 영역, Stack 영역, Heap 영역, Native Method Stack 영역에 대해 알아본다.
JVM의 인스턴스가 사용하는 자원 저장소(Context)에 대해 설명한다.

- **Class Context**
    - Static Scope으로 접근되는 Context이다. 클래스에 대한 코드와 상수가 저장된다.
    - JVM은 클래스를 로딩하고 Class Context에 저장한다.
    - Class 안에는 메서드가 존재하고 메서드 각각은 객체로 인식될 수 있기 때문에 개념적으로 이 Context에 메서드 Context가 있다고 이해할 수 있다.
    - 상수들은 심벌 테이블인 Constant Pool에 저장된다. Constant Pool은 Class마다 존재한다. 상수에는 숫자형, 문자형이 모두 포함된다.
    - 상수 적재 명령에서 사용되는 상수들은 Constant Pool에 저장되지 않는다. 상수 적재 명령은 컴파일 시에 미리 값이 지정되어 버리기 때문에 따로 저장되지 않는다.
    - 일반적으로 Constant Pool에 저장된 상수 데이터는 관련 명령을 통해서 가져온다. 기본적으로 GC가 발생하지 않는다고 생각하면 된다.
    - **정리하면, 클래스를 정의할 때 볼 수 있는 상수들로 interface 명, 부모 클래스 명, 필드 명, 메서드 명과 같은 소스 코드 상의 심벌들과 그 외의 여러 상수와 메서드 호출 구조 등이 이곳에 저장된다.**
- **Stack Context**
    - 이 Context는 Stack Scope와 대응된다.
    - Stack Context는 기존 언어에서와 마찬가지로 메서드가 호출될 때마다 생성되는 스택 프레임을 의미한다.
    - 다음의 것들이 저장된다.
        - 피연산자와 반환 값을 저장하기 위한 연산자 스택(Operand Stack)이 저장된다.
        - 현재 수행중인 연산의 위치를 나타내는 프로그램 카운터(PC)를 저장한다.
        - 지역 변수의 배열이 저장된다. 객체의 메서드일 경우 매개변수 배열 0번에 현재 객체의 참조 값이 전달되어 저장된다. (클래스 메서드일 경우에 0번에는 아무 것도 전달되지 않는다.)
    - 자료 구조가 스택이므로 최상위에 있는 Context가 현재 수행 중인 Context이고, 이를 활성화 스택 프레임이라고 한다.
- **Heap Context**
    - 이 Context는 Heap Scope와 대응된다.
    - 대부분의 객체가 저장된다.
    - new 연산자를 자바 코드에 명시했다면 이 Context에 객체가 생성되고 사용 후 소멸된다.
    - Class의 메타 정보가 Class Context에 있기 때문에 이미 정의된 클래스 자체의 동작 코드를 실행시간에 바꿀 수 없다.
- **Native Method Stack Context**
    - 이 Context는 Java Native Interface(JNI)를 사용하는 메서드의 호출 스택을 제공한다. JVM의 명령 집합을 통해서 I/O를 직접 수행할 수 없다. 각 플랫폼마다 달라질 수 있고, 특정 플랫폼에 최적화된 형태로 구현된 것을 가져와서 사용하게 된다.
    - 자바에서는 이런 언어 확장을 위해 JNI를 제공한다.
    - 이 Context에 있는 객체가 JVM 외부 메모리 영역을 사용할 경우 GC가 되지 않는다.
    - 정리하면, 자바에서 직접 구현하기 어렵고, 특히 성능 향상을 목적으로 OS에 특화된 기능을 사용할 때 JNI를 사용한다.
