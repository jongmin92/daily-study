# 절차지향 언어와 객체지향 언어
- 흔히 C언어는 절차지향, Java는 객체지향 언어로 많이 예시를 든다. 어떤 차이가 있을까?
- C언어
    - 대부분의 로직을 절차(순서)에 기반하여 작성한다.
    - 보통 변수 혹은 별도의 struct를 정의해서 데이터를 저장.
    - 저장된 데이터를 이용하는 제어문, 반복문을 통해 프로그램을 작성한다.
    - 당연히, 로직을 재사용할 수 있도록 같은 목적을 가진 코드 블럭은 함수로 만들어 사용한다.
    - 다형성과 같은 것을 구현하기 위해 함수 포인터와 디스패치 테이블(실제 처리하는 함수로의 매핑 테이블)을 사용한다.
- Java
    - 프로그램을 이용해서 해결하고자 하는 문제를 실세계에 대입해서 풀려고 한다.
    - 모든 것은 객체들의 상호호환으로 이루어진다.
    - 그러다보니, 간단한 main문 조차 class 내부에서 정의되어 실행된다.
        - 여러 객체들에 대해서 사용되는 일반적인 util 목적의 메서드 또한 별도의 클래스로 정의가 되어야한다.
    - 객체가 자신의 특성과 연관된 데이터를 갖고, 메서드를 이용해 데이터를 조작한다.

프로그램을 작성할 때, 언어의 특성을 잘 알아야만 하는 것 같다. 아니 그래야 한다.
C언어를 처음 배우고 Java를 배웠던 당시를 생각해보면, 작성하고 있는 코드는 Java인데 마치 C언어를 이용해 프로그램을 작성하는 식으로 만들었던 것 같다.

지금 생각하면 웃기지만... 어찌보면 Java를 이용해 C언어 처럼 코드를 작성하던 것을 지금은 Kotlin을 갖고 Java처럼 작성하려고 하는 것과 비슷한 것 같다. 

아무 생각없이 그냥 문법만 공부해서 작성하면 같은 일을 되풀이할 뿐이다. 왜 Java에는 없는 문법이 만들어졌는지도 고민하면서 작성해보면 더 잘 활용할 수 있을 것이다.

# 컴파일 언어와 인터프리터 언어
코드를 작성한다고 변수가 바로 메모리에 생기고 코드가 동작되는 것이 아니다. 코드를 작성하는 동안은 실제 동작하는 것이 아니고, 어떤 변수가 사용될 것이라는 것만 선언된다. 이때를 `선언 시간`이라고 한다. 그리고 CPU
나 가상 머신이 실제 변수를 사용해서 처리 중일 때는 `실행 시간`이라고 한다. **선언 시간에서 실행 시간으로 가는 과정을 기준으로 컴파일 언어와 인터프리터 언어로 나눌 수 있다.**

- 컴파일 언어
    - 선언 시간을 거쳐서 컴파일과 링킹을 통해 실행 코드가 생성된다.
    - 실행 코드는 운영체제에 의해 읽혀지고 CPU는 실행 파일의 코드 부분만을 처리한다.
    - 자바나 C#은 각각 Byte Code, MSIL 같은 중간 코드를 만들고, 가상  중간 코드를 로딩한 후 이해한 코드를 CPU가 처리하도록 요청한다.
    - 컴파일은 소스 코드를 파싱하고 추상 구문 트리를 만들어서 최종적으로 심볼 테이블을 만드는 과정이다.
        >심볼 테이블: 소스 코드 상에서 나타난 의미 있는 구문들의 심볼과 변수 값이나 함수와 같은 것을 맵핑하는 테이블
- 인터프리터 언어
    - 인스턴스나 객체를 생성하는 과정이 조금 다르다.
    - 코드 작성을 마치고 인터프리터를 구동시키거나 구동한 후에 코드를 작성해도 된다.
    - 인터프리터 언어 역시 인스턴스는 실행 시간에 존재하지만, 인터프리터가 먼저 구동된 경우에 실행 시간에도 동적으로 인스턴스가 추가될 수 있다.
    - 실행 시간이 되어서 심벌(변수)이 무엇인지 판별한다. -> 오류를 만들기 쉽다.

언어는 인스턴스를 만들고 이를 사용해서 코드를 동작시키는 일을 하는 것이다. 인스턴스는 언어마다 다르게 표현될 수 있다. 내장 데이터 타입, 구조체, 공용체, 클래스, 함수, 객체 등등... (클래스는 객체의 메타 정보를 가지는 인스턴스이다.)

# Scope, Context
Scope는 접근 가능한지 판단하는 영역, Context는 Scope를 통해서 보호되는 저장된 인스턴스들 모임이다.

## Scope
메서드나 필드를 선언하고 사용할 때, Scope를 고려해야 한다. 영역 바깥에 있다면 존재하더라도 사용할 수 없다.

- Static Scope
    - 정적으로 존재하는 영역이기 때문에 객체를 생성하지 않고도 접근할 수 있는 영역이다.
    - 프로그램 시작부터 계속 상주하게 되는 영역이다.
    - C의 전역 변수나 자바에서 static 키워드로 명시되는 멤버 필드나 멤버 메서드에 적용된다.
    - Static Scope는 공유되는 영역이라고 생각할 수 있다.
- Stack Scope
    - 메서드 호출과 {블록}을 통해 생성되는 영역이며, 메서드와 블록들 사이에서 접근이 제한된 영역이다.
    - 메서드 안에서 선언된 변수와 매개변수는 지역 변수라고 부른다.
        - 외부에서 접근할 수도 없고, 함수가 반환되면 메모리에서 자동적으로 사라진다.
    - 자바에서 Stack Scope에 있는 인스턴스가 객체 참조 값일 경우에 모든 Scope의 인스턴스를 가리킬 수 있다. 값이나 참조가 반환 되더라도 소멸되지 않기 때문이다.
        - 모든 소멸은 JVM이 관리하기 때문에 가능하다.
    - 객체에서의 메서드 호출은 0번 매개변수로 현재 객체의 참조 값이 전달되므로 블록을 통해 Stack Scope가 생성되더라도 객체 안의 멤버 필드나 멤버 메서드에 접근할 수 있다.
- Heap Scope
    - 수동으로 생성과 소멸을 필요로 했던 영역이며, 참조 값이 저장된 어디든지 접근할 수 있는 영역이다.
    - 응용 프로그램의 메모리 대부분을 차지하고 있다.
    - 인스턴스가 소멸되면 크기가 줄어든다.
    - 자바 개발자는 참조가 필요 없어지면 그냥 두거나 null 참조를 할당한다.
        - C나 C++ 개발자는 Heap Scope에 인스턴스를 생성하기 위해 malloc()이나 new와 같은 함수나 연산자를 사용하고, 소멸을 위해서는 free()나 delete 같은 함수나 연산자를 사용했다.
    - 자바 언어 설계자는 Heap Scope을 통해서 접근 가능한 인스턴스를 프로그래머 대신 소멸 해주는 장치를 만들었다. => GC(Garbage Collector)
- Shadowing
    - 다른 Scope에 존재하는 동일한 이름의 변수가 있을 때, 현재 Scope에서 멀리 있는 변수가 보이지 않게 되는 현상.
```java
class ShadowFather {
    protected int shadowTarget = 15;
}
public class Shadowing extends ShadowFather {
    private int shadowTarget = 0;
    public void printShadowedValue() {
        int shadowTarget = 26;
        System.out.println(shadowTarget);
    }

    public static void main(String[] args) {
        new Shadowing().printShadowedValue();
    }
}
```
- Class Declared Scope
    - 이전의 Scope의 관점에서는 접근할 수 있는 멤버 필드나 메서드일지라도 접근을 하거나 접근하지 못하도록 명시할 수 있는 영역이다.

자바에서는 추가적으로 Annotation 같은 특징을 통해서 Scope을 추가할 수 있다.

## Context
- Context는 범위보다는 자원을 나타낸다.
- 제어를 얻은 시점에서 접근할 수 있는 모든 자원을 의미한다.
- Context를 다루는데 있어서 가장 중요한 것은 Context 내에 존재하는 자원이나 인스턴스의 진입점을 찾는 것이다.
    - 진입점을 기준으로 크게 지역 Context와 분산 Context로 나눌 수 있다.
    - 지역 Context의 진입점은 참조 변수이다.
    - 분산 Context 네트워크를 통해 접근할 수 있는 자원을 의미한다. (저수준에서 소켓을 의미한다.)
